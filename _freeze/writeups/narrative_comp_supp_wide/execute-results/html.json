{
  "hash": "85ee474d6390f3cb98047b282d8b6de1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"narrative_comp_supp_wide\"\noutput: html_document\n---\n\n# *Complementary Data Suppression in R*\n\n#### *Code, Explanation, and Example Implementation*\n\nComplementary data suppression is a technique used to protect data privacy in datasets that include small cell counts. For a full explanation of CDS, see the Connecticut State Department of Education's document on methodologies and rules: [Data Suppression Guidelines.](https://edsight.ct.gov/relatedreports/BDCRE%20Data%20Suppression%20Rules.pdf)\n\nUsing CSDE's example cutoff values and a dummy dataset, this document walks its reader through the process of carrying out CDS as part of an R pipeline. More information on assumed data format and CDS implementation is detailed throughout the various steps.\n\nIf you would like to directly access the fully-commented R script that forms the basis for this narrative explanation, *click here.*\n\n#### 1. Load your libraries, prepare your data, and define your values.\n\nIn order to perform any data manipulation, we need to load our relevant libraries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) # Basic data manipulation\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(here) # NOT NECESSARY for user, needed for loading data into markdown\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /home/alex/repos/complementary_suppression\n```\n\n\n:::\n:::\n\n\nFor the sake of this explanation, we will be using a dummy dataset. This script assumes that the user's data is in wide format. If that is not the case, you can use `pivot_wider` to easily make the necessary change, as detailed in the code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reading in data\ntabdata <- read_csv('../data/burner_tabdata.csv') #fix\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 9 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): school, county\ndbl (3): hispanic_count, white_count, black_count\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Printing to see structure\ntabdata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 5\n  school county    hispanic_count white_count black_count\n  <chr>  <chr>              <dbl>       <dbl>       <dbl>\n1 abc    tolland                0          50           2\n2 def    tolland                3          80           0\n3 ghi    windham               10          20          23\n4 jkl    windham               15          15          12\n5 mno    windham                8          34           3\n6 pqr    avon                   5          23           5\n7 stu    avon                   6           4           6\n8 vwx    hartford              20           0          23\n9 yz     fairfield             30           3           2\n```\n\n\n:::\n:::\n\n\nFollowing CSDE guidelines, we will be using a cell count cutoff value of 6 (cells with values equal to five or less will be suppressed). In calculating ratios, we will suppress values with numerators equal to or less than five or denominators equal to or less than 20. These ratios should be calculated and suppressed before the cell count values are examined. We will also define our suppression character to be \"\\**\".* Because *\"*\\*\" is a special regular expression character (string detection language), we will account for that here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Suppression values of choice\ncell_bound <- 5\nnumerator_bound <- 5\ndenominator_bound <- 20\n\n# Suppression character to be used\nsupp_char <- '*'\n# Define regex version of supp_char in case it is a special character\nregex_suppchar <- if_else(\n  supp_char %in% c('*', '.'),\n  paste0('\\\\', supp_char), # Escape slashes for literal character interpretation\n  supp_char\n)\n```\n:::\n\n\n#### 2. Calculate your aggregate fields and check for suppression.\n\nIs your data in long format? If so, now is the time to pivot to wide. Use `pivot_wider`! Because our data is already in wide format, we won't use this. If you need to, uncomment this line of code and fill in the blanks. Check out the [documentation and examples](https://tidyr.tidyverse.org/reference/pivot_wider.html) if this is new to you.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tabdata <- pivot_wider(tabdata, names_from = name_column, values_from = value_column)\n```\n:::\n\n\nNext, we will calculate our ratios and aggregate fields. For this example, we are calculating count totals and ratios.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Carry out suppression of percentages and aggregates before individual numbers\ntabdata <- tabdata |>\n  mutate(\n    total = hispanic_count + white_count + black_count, # Total counts\n    hispanic_perc = if_else(\n      # Suppression criteria:\n      (hispanic_count < numerator_bound) | (total < denominator_bound),\n      # If not met, suppress value:\n      supp_char,\n      # Else, store value as string.\n      as.character(round(hispanic_count / total, 2))\n    ), # Rounding for appearance\n    black_perc = if_else(\n      (black_count < numerator_bound) | (total < denominator_bound),\n      supp_char,\n      as.character(round(black_count / total, 2))\n    ),\n    white_perc = if_else(\n      (white_count < numerator_bound) | (total < denominator_bound),\n      supp_char,\n      as.character(round(white_count / total, 2))\n    )\n  )\n# Current data structure and suppression:\ntabdata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 9\n  school county    hispanic_count white_count black_count total hispanic_perc\n  <chr>  <chr>              <dbl>       <dbl>       <dbl> <dbl> <chr>        \n1 abc    tolland                0          50           2    52 *            \n2 def    tolland                3          80           0    83 *            \n3 ghi    windham               10          20          23    53 0.19         \n4 jkl    windham               15          15          12    42 0.36         \n5 mno    windham                8          34           3    45 0.18         \n6 pqr    avon                   5          23           5    33 0.15         \n7 stu    avon                   6           4           6    16 *            \n8 vwx    hartford              20           0          23    43 0.47         \n9 yz     fairfield             30           3           2    35 0.86         \n# ℹ 2 more variables: black_perc <chr>, white_perc <chr>\n```\n\n\n:::\n:::\n\n\n#### 3. Define your suppression columns.\n\nThese are the columns containing the counts we want to apply complementary suppression to. In the case of this example, we are suppressing `white_count`, `black_count`, and `white_count`. We already carried out suppression on our aggregate columns, so those aren't included here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Columns (COUNTS) to apply complementary suppresion to\nsupp_cols <- c('white_count', 'black_count', 'hispanic_count')\n# Indices of suppression columns, for later manipulation\nsuppcol_idx <- which(names(df) %in% supp_cols)\n```\n:::\n\n\n#### 4. Write your suppression algorithm. \n\nNow we'll write our functions for suppression. If implementation is not of concern to you, copy the code below and skip to step 5.\n\nFirst, we'll write the function to be called in the main script. This function will perform a first pass on all data values in the suppression columns and suppress values equal to or smaller than our cutoff value (previously defined with cell_bound). Afterwards, this function calls `complementary()`, our recursive function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppress <- function(df, supp_val, supp_char, supp_cols) {\n  # First pass:\n  # For all suppression columns (supp_cols), replace any cell value equal to\n  # or less than suppression value (supp_val) with suppression character\n  df <- df |>\n    mutate(across(\n      supp_cols,\n      ~ if_else(\n        .x <= supp_val & .x != 0,\n        supp_char,\n        as.character(.x)\n      )\n    ))\n\n  # Call recursive function to perform complementary suppression\n  df <- complementary(df)\n  return(df)\n}\n```\n:::\n\n\nRecursive functions continually call themselves until reaching a base case, where they have reached the desired condition and break out of the loop. We need a recursive function because we want to repeatedly change our dataframe until we find that each row and column passes the necessary conditions outlined by CSDE: zero or two or more values suppressed in each row and column to prevent values from being discoverable using marginal totals. `complementary()` calls a series of helper functions to perform this task.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplementary <- function(df) {\n  # Checker dataframe needs to be remade every recursive call\n  checker <- checker_df(df)\n\n  # Base case: check_rows() returns NULL AND check_cols() returns NULL\n  rows_to_fix <- check_rows(checker)\n  print(rows_to_fix)\n  cols_to_fix <- check_cols(checker)\n  if (length(rows_to_fix) == 0) {\n    if (length(cols_to_fix) == 0) {\n      return(df) # Base case\n    }\n    df <- fix_all_cols(df, cols_to_fix)\n  } else {\n    df <- fix_all_rows(df, rows_to_fix)\n    if (length(cols_to_fix != 0)) {\n      df <- fix_all_cols(df, cols_to_fix)\n    }\n  }\n\n  # Recurse with edited dataframe\n  complementary(df)\n}\n```\n:::\n\n\nLet's define all of our helper functions, starting with `checker_df()`. This function creates a burner dataframe that can be easily used to check whether there are a passing number of suppressed values in each row and column. The dataframe produced by `checker_df()`, `checker`, is passed into `check_rows()` and `check_cols()` to test if the dataframe has reached its base case.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Forms burner dataframe with columns verifying value suppression\nchecker_df <- function(df) {\n  checker <- df |>\n    # If a value has been suppressed, replace it with 1.\n    # If a value has not been suppressed, replace it with 0.\n    mutate_at(supp_cols, ~ as.numeric(str_detect(., regex_suppchar)))\n\n  return(checker)\n}\n\ncheck_rows <- function(checker) {\n  row_checker <- checker |>\n    # How many cells in a given row have been suppressed?\n    mutate(num_supp = rowSums(checker[, suppcol_idx])) #All rows, only suppression columns\n  # What are the indices of the rows that need to be fixed (have only 1 value suppressed)?\n  fix_rows = which(row_checker$num_supp == 1)\n  return(fix_rows)\n}\n\ncheck_cols <- function(checker) {\n  # How many cells in a given column have been suppressed?\n  colSums(checker[, which(names(checker) %in% supp_cols)])\n\n  # What are the indices of the columns that need to be fixed (have only 1 value suppressed)?\n  fix_cols = which(colSums(checker[which(names(checker) %in% supp_cols)]) == 1)\n  return(fix_cols)\n}\n```\n:::\n\n\nIf `check_rows()` or `check_cols()` returns a list of column indices that need to be fixed, we call our helper functions to fix them using `fix_all_rows()` and `fix_all_cols()`, which simply serve to iteratively call `fix_row()` and `fix_col()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Iterate through all rows to be fixed\nfix_all_rows <- function(df, rows_to_fix) {\n  # Could be consolidated with map() functions, but left as-is for readability\n  for (i in rows_to_fix) {\n    df <- fix_row(df, i)\n  }\n  return(df)\n}\n\n# Iterate through all columns to be fixed\nfix_all_cols <- function(df, cols_to_fix) {\n  # Could be consolidated with map() functions, but left as-is for readability\n  for (i in cols_to_fix) {\n    df <- fix_col(df, i)\n  }\n  return(df)\n}\n\nfix_row <- function(df, i) {\n  # Save row to be fixed as vector, remove suppressed values, convert to numeric\n  row <- df[i, suppcol_idx]\n  num_row <- as.numeric(row[!(row %in% c(supp_char, \"0\"))])\n\n  # Randomly choose the index of one cell equal to the minimum row value to suppress\n  # Subtract 1 to switch from 1-based indexing to 0-based indexing for data subsetting\n  poss_idx <- which(row == min(num_row))\n  if (length(poss_idx) != 1) {\n    idx_to_supp <- sample(poss_idx, size = 1) - 1\n  } else {\n    idx_to_supp <- poss_idx - 1\n  }\n\n  # Suppress selected cell with suppression character\n  # Second argument enables proper indexing into larger dataframe:\n  #idx_to_supp = index of column within relevant suppression columns\n  #suppcol_idx[1] = starter index of first relevant suppression column\n  df[i, idx_to_supp + suppcol_idx[1]] <- supp_char\n  return(df)\n}\n\nfix_col <- function(df, i) {\n  # Save column to be fixed as vector, remove suppressed values, convert to numeric\n  col <- df[, i]\n  num_col <- as.numeric(col[!(col %in% c(supp_char, \"0\"))])\n\n  # Randomly choose the index of one cell equal to the minimum column value to suppress\n  poss_idx <- which(col == min(num_col))\n  if (length(poss_idx) != 1) {\n    idx_to_supp <- sample(poss_idx, size = 1)\n  } else {\n    idx_to_supp <- poss_idx\n  }\n\n  # Suppress selected cell with suppression character\n  # Second argument enables proper indexing into larger dataframe:\n  #i = column being fixed\n  #idx_to_supp = row of column to be suppressed\n  df[idx_to_supp, i] <- supp_char\n  return(df)\n}\n```\n:::\n\n\n#### 5. Call complementary suppression function. \n\nLet's use our call stack! Since all of our values are defined from step 1, we can plug-and-chug with our new functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Call initial function, which engages all other helper functions\nsuppressed_tabdata <- suppress(tabdata, cell_bound, supp_char, supp_cols)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(...)`.\nCaused by warning:\n! Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(supp_cols)\n\n  # Now:\n  data %>% select(all_of(supp_cols))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\ninteger(0)\n```\n\n\n:::\n\n```{.r .cell-code}\n# Print!\nsuppressed_tabdata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 9\n  school county    hispanic_count white_count black_count total hispanic_perc\n  <chr>  <chr>     <chr>          <chr>       <chr>       <dbl> <chr>        \n1 abc    tolland   0              50          *              52 *            \n2 def    tolland   *              80          0              83 *            \n3 ghi    windham   10             20          23             53 0.19         \n4 jkl    windham   15             15          12             42 0.36         \n5 mno    windham   8              34          *              45 0.18         \n6 pqr    avon      *              23          *              33 0.15         \n7 stu    avon      6              *           6              16 *            \n8 vwx    hartford  20             0           23             43 0.47         \n9 yz     fairfield 30             *           *              35 0.86         \n# ℹ 2 more variables: black_perc <chr>, white_perc <chr>\n```\n\n\n:::\n:::\n\n\n#### Notes:\n\nThis code could be easily optimized and made concise. Excessive helper functions were used to improve readability and ease of functionality. Inspiration for implementation taken from open-source [dar-tool](https://pypi.org/project/dar-tool/), a Python tool performing complementary suppression.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}